# 数据表示

## 补码

### 补码的原理

- 相差 模的**正负倍数**的数，具有**同余关系**

- **补码**是将寄存器所存储的 **最大值+1** 作为模，通过**同余关系**将负数进行转换

- **补码**用于将作**减法**运算的数通转换为正数

  由于寄存器的位数有限，因此计算机中的数据进行的是带模运算。

  - 若寄存器为n+1位，若在全1之后再+1，则实际值为$2^{n+1}$,将符号位进位后的权值设为模，也即将溢出量设为模。
  - 根据同余关系，利用模，对负数进行补码转换。
  - 该寄存器有n+1位，第一位符号位，但实际参与运算。可以表示真值次方为n的正负数。
  - 当真值范围为[0~$2^n-1]$的正数时，第一位为0，其它位与真值一致
  - 当真值范围为[$-2^n+1$,0]的负数时，第一位为1，考虑n+1位的寄存器的值为$2^{n+1}+X$,本质上为在第一位为1的情况下，其余位与正数的X互补，换句话说，是在保证为正数的情况下，使用n+1位，避免与使用n位的正数补码混淆。
  - 负小数同理，由于负小数变补之后，小数点前为1，小数点后与正数小数互补。因此应该+2.
  - 注意由于$+2^n$与$-2^n$，+1和-1补码重合，因此我们只保留$-2^n$的补码

- 特征

  - 零有唯一的表示形式
  - -1.0的补码为1
    - -1+2=1
    - 由于正数不包括1，因为+1和-1的补码形式一样
    - 补码相对原码少一个-0，多一个-1

### 补码的使用

- 真值直接取二进制原码，符号为0
- 负数逐位取反，符号为1，末尾+1，溢出位不管，只管到小数点前1位
- **扫描法**：从最右侧扫描，在没有遇到第一个1前都不变，直到取到第一个1之后的数逐位取反，符号为为1.
- 变补运算/机器负数  
  - 已知[X]补，求[-X]补
    - 注意与负数的补码不同，负数补码不对符号位取反
    - 将[X]补再次求补
      - 连同符号位一同变反，末尾+1
      - 扫描法

